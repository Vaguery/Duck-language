#encoding: utf-8
require_relative '../lib/duck'
include Duck

bad_boy = interpreter(script: "^script 0.6 F * ^greedy= F x emit F T x x ^ticks keep 1.6 swap 9 / x []= x 1 fold_up x dec count_by F 1 - -5.3 7.2 halt []= x - ∩ to_interpreter 0 copies ^length -0.7 2 ^fork T 7 7 copies give index= T to_list greedy 3 3 give ^script be rewrap_by -1.0 -1.2 7 ^rescript F -2.7 6 step 9.6 inc give 0 ÷ * x F T 2 halt - greedy? dec x dec T x ^script / bundle times_do if zap ungreedy x 0.2 if x 1.1 unshift index= 5.3 shift", binder:{x:int(27)})




begin
  bad_boy.trace!.run
rescue NoMethodError => e
  puts "\n\nERROR #{e.backtrace} #{e.message}: #{bad_boy.inspect} after #{bad_boy.ticks} ticks; staged: #{bad_boy.staged_item}"
end


# NOT FIXED: 
interpreter(script: "5 index= wrap run T ¬ times_do ceiling rebind keep to_script -8.8 ≤ reverse be ∧ infold_up above push ^fork ∩ to_binder eql x dec infold_down dec infold_up / -5.3 step x / ≤ 0.7 flatten to_interpreter 0 -2.5 ^length 1.0 < ^fork 8 4 0.3 2 > T ungreedy 8 useful x eql ^script F -8.7 x ¬ 8 dec shift ∧ rebind - F 6 to_decimal each 0.2 length F trunc 0.1 0 -8.9 do -0.5 x dec [] 6.9 snap ^ticks cover? ceiling F to_interpreter 8 if eql - flatten T above T [] bundle x to_binder", binder:{x:int(27)})


interpreter(script: "-2.3 ^fork -9.2 9 ∩ run x ^fork 3.0 inc 6.2 8 F to_span T copy -7.5 - x 8.3 step step push 5 ∧ if to_binder []= each 7 x 5.1 rewrap_by emit F / 6.9 dec know? ^ticks", binder:{x:int(27)})

interpreter(script: "¬ shatter ^length - bundle 8 bundle x to_binder reverse eql count_by step x zap rotate to_binder > ^rescript infold_down ∩ reverse to_binder times_do know? if again 7 fold_down 7 emit 7.3 map to_decimal dec bundle 6 rewrap_by do x", binder:{x:int(27)})

interpreter(script: "to_int below -8.2 to_interpreter to_interpreter each []= 4 F to_span x ≥ 8 F _o x _v eql 4.6 cover? count ^rescript shatter shift ∨ pop 7 ≤ push 6 - -7 zap push map _s -1 inc cover? give flatten bundle above trunc to_interpreter rotate ∨ above to_script _k each eql _j < do ∧ be T -5.1 _w x ∧ ∪ bind count F ^fork to_bool zap push be _q 1 each ^ticks bundle above useful F halt know? to_interpreter to_binder -3 push F each map inc x -8.4 x map pop T to_span 3 x _g 2.5 neg infold_down x F greedy useful copy ^rescript x x F F F F flatten emit each 2.2 map F to_binder 5 9 _p -5 greedy? x F -0.8 x ∩ greedy each to_script ∪ + lowercase x F 3 + _y ^greedy= empty halt rewrap_by unshift x ^rescript copies x -1.3 halt 1.3 lowercase neg 4 _s ^rescript T flatten ^script push 1.5 ^greedy= ^greedy= F T to_binder 8", binder:{x:int(3)})




# JUST SLOW

interpreter(script: "below -7.2 T above cover? flatten to_span fold_down 8 x ∨ if ^script greedy? infold_down emit ∧ be - neg 0.5 keep snap ^script swap if empty -4.9 infold_down ¬ x x x ≥ T cover? T x -7.6 to_binder 5.7 zap pop 7.4 to_decimal ^rescript _v F T _s snap step emit -3 to_interpreter push -4 ≥ users ^script ^greedy= ∧ x keep length -8 ^ticks step shift map step emit rebind ^rescript -5 ^script F -7 F + x infold_up < infold_up snap do x wrap ^greedy= bundle", binder:{x:int(30)})



# FIXED ?

# interpreter(script: "4 infold_up x ^greedy= _v do shift map ^fork ≥ again neg 7.8 x index= 8.5 bind rewrap_by _n rand empty ^fork x x copy ^quote 3.7 _z reverse bundle -3 shatter 7.7 []= bind _q keep T ∪ lowercase ÷ cover? ∪ + -0 trunc _b ∪ bundle 9 x rewrap_by infold_down to_binder bundle x to_interpreter 0.3 ^greedy= to_interpreter x eql dec ceiling ^rescript ^script ¬ x eql copies to_interpreter x count ∪ x ¬ to_assembler each copy [] to_decimal 8 dec F _f trunc 9.3 give empty x push pop eql -3 push rebind _d _b above -0.6 wrap count_by ^script -5.6 -3.1 T x infold_up push greedy? x ungreedy flatten x x trunc below zap -6.9 eql ¬ floor count dec []= rebind x to_interpreter -1.2 run to_bool to_int lowercase x -8 T to_list run -9 if * snap shatter -4 ^quote lowercase to_assembler _y x rebind + below -2 run T 1 dec above -8.1 rotate", binder:{x:int(3)})

# interpreter(script: "F F - to_span 1.8 wrap ^length T pop fold_down -9 x _k x ^fork -7 map [] emit shatter x trunc _m ^script step + count_by copy > swap copy _f T x lowercase 5.5 to_int ∪ F swap F fold_down x 0.2 -4.1 to_bool inc be ∪ infold_down _u length ^script ≤ 2 F _q to_span _g shatter ^rescript fold_down below _a ^quote infold_down count_by _y -3.5 ^greedy= rand _s rebind < x neg 7.6 shatter -3 useful T below - empty ≥ F inc -7 copies halt to_list F 8 infold_up each count lowercase neg x length ∪ copy ^script bind > run index= _i ^ticks < _s _j _f ^fork to_binder ∪ users useful -0.3 fold_down 4.2 fold_down > < F x x _y < if < ^fork ^length -2.0 again count ≥ ^ticks pop step _f rebind cover? x 4 give count_by ∨ ^ticks reverse * 8 snap T -3.9 _h greedy useful give T", binder:{x:int(3)})

# interpreter(script: "_q to_span > T fold_down 2 ∧ 5 map if ^fork x cover? T ≤ step F T -4 ^length -9 greedy? _i 6.9 fold_down fold_up [] 8.5 shift x - to_interpreter to_binder each to_script F rewrap_by _g x ≤ reverse known[] ≥ ∧ T to_assembler < be neg pop map T to_span ÷ + wrap inc T each infold_down each known[] push 0 rebind count _c 7.0 _z halt x to_binder _h -6 to_assembler below ÷ 0 ∩ ∪ useful rotate T 0.7 ^greedy= fold_up x to_decimal ∪ -8 -5 to_int x above run times_do above fold_down -3.2 ^fork cover? 2 to_decimal F again infold_up halt ^rescript if to_interpreter F x 1 to_decimal ÷ -1.6 each T wrap to_assembler length to_interpreter x _j keep [] length rand unshift > if know? do -9.8 users x count ∧ ∧ F be bundle shatter length x copy -8 T swap -2.9 snap T fold_up emit ^length ^quote map trunc again bundle F rotate ^length x halt F 9 know? 2.6 -5.6 reverse < F -0.3 greedy ^script reverse give to_script _z known[] _h fold_up _c fold_up emit to_interpreter _z F x", binder:{x:int(3)})

# interpreter(script: "¬ -7 x shatter F bind above ÷ ≤ flatten infold_up _o trunc ^script 9.3 - T to_decimal x ¬ rotate eql -7 fold_up cover? snap ∧ + -3 _c bundle inc 6.9 _t emit x to_span to_list -2.2 to_list []= -1 -3.1 wrap known[] eql halt do 3 > keep trunc below 4.1 4.4 to_int < 1.8 to_span inc -1 _t keep > F above trunc _h again infold_down empty _u ^length count bundle -9 [] swap x * 8.7 to_assembler known[] pop step ^ticks _z do _t ungreedy F -4 bind - map T each T rewrap_by -0 greedy? ∪ to_bool 7 trunc -1.2 give x ≥ to_span bind 4.5 -1 _j ^fork zap neg map push bundle", binder:{x:int(30)})

# interpreter(script: "∪ T to_list know? empty F times_do -1 ^rescript _f below times_do ungreedy 2.5 ^fork neg again _s copies each cover? trunc ^rescript to_span -8.0 ^ticks to_decimal 9.0 T ^fork 4 0 greedy? fold_down ^greedy= 6.3 F rand unshift ≤ x F 5.0 6 _t rotate shatter each eql -5 users ^rescript length -8 step unshift T run keep ∩", binder:{x:int(30)})

# interpreter(script: "4.6 rotate ∪ _g swap 6 -9 _p rebind _y -8.6 []= to_int T run -6.6 emit _l 8.6 4 lowercase keep users x -9.4 times_do T flatten neg x -1 T useful x x greedy? zap to_assembler x x to_binder rotate 8.4 to_span ^length 1.2 rewrap_by ^script F times_do ^quote halt copy ^length rand _s push T T -2 inc keep 6 3.3 -6 to_interpreter + _x neg unshift - x ∨ reverse x ≥ cover? ≤ greedy x bundle _c eql T T halt cover? [] fold_down T F greedy ^length to_interpreter give fold_down empty -9 shatter T + ¬ ∧ give F 4 to_decimal ^rescript _d _d empty _o -3 shatter greedy -6 x < -2 rebind neg ^fork keep shift lowercase ^rescript shatter _g _k pop shift greedy? push times_do ∩ 6.3 ≥ if neg to_list ∨ 2.8 snap halt _i x useful 0 x map x _x lowercase x empty T push length lowercase to_binder below F step 7.5 T step copies ≤ copy to_interpreter", binder:{x:int(30)})

#interpreter(script: "empty []= fold_up swap F infold_up rand _n keep ^greedy= lowercase greedy? * x rewrap_by [] shatter -1.5 ^fork _c 7.9 to_int to_decimal T below ÷ ungreedy ^length F x T _t ^greedy= ∩ times_do run x neg wrap 9 -4.6 snap 9 to_binder _u x -2.6 bundle ungreedy be shift greedy? know? -9 x greedy? neg x rewrap_by keep ^length []= fold_down x 1 rotate rewrap_by 1.9 to_int rand bind to_assembler _d -8.6 x ≥ cover? rebind above wrap map _k _h to_interpreter x _c inc zap push bind", binder:{x:int(-30)})

# interpreter(script: "fold_down -1 ^greedy= copy -9 x unshift ^length F _o x greedy ÷ 7.5 unshift fold_down -5 x swap shift below reverse keep 2 _t 7 known[] empty copies push ≤ times_do 8.6 give _b greedy x ^rescript greedy give fold_up x known[] shift _w fold_up below give emit rotate times_do x greedy? trunc rand x ungreedy + know? greedy? run _e to_int 4 x to_list x lowercase 9 x below to_binder ^greedy= x rotate -7.2 ^quote infold_up rewrap_by x fold_down rebind to_span to_int _x x if _t infold_down shatter give useful ¬ if infold_up to_span T rand infold_up bundle to_decimal 2.0 emit [] rand pop inc > halt below bind > bind rand do neg x x ∨ x 6.5 < to_bool keep run x to_span step ungreedy F do ∨ infold_down _x _j -1 reverse rotate x 8 greedy? 1 be ^script run rebind reverse T _v to_span T to_decimal x 7.3 give x -2.1 x fold_up ∨ _t F ≤ zap wrap T give 8.2 T _a * x do to_binder -9 flatten 4.1 ^greedy= _m _o", binder:{x:int(30)})

# interpreter(script: "[] x 9 1.6 be unshift F -6 ^length pop 7.8 lowercase - fold_down T -2.7 to_assembler emit cover? above rand 1.3 rewrap_by 9 _y _g to_decimal ∨ infold_down F _f x ≤ greedy run pop * ≤ _c rand to_int 1 x below infold_up unshift ÷ + fold_up x greedy -0.9 fold_up -8 ∧ to_bool 4 ungreedy -7.7 _e - fold_up _x known[] _v infold_down rotate 5 x infold_down F []= 7 []= _z x swap _m x _g to_assembler to_int map _s unshift x to_bool ^script swap ∪ eql _b bind F T eql -2 fold_down useful copies _k -8 _m zap ^script -7.3 5 eql x 7 known[] -0.6 ≤ x _e ^rescript map push cover? x rewrap_by push 9 known[] x ^rescript wrap neg ^rescript wrap x cover? -2 x shift below _w step 4.3 x -2.8 greedy ^fork x ∪ rand empty to_interpreter x 9.0 bundle ^script T 2.5 ^rescript F give - halt ÷ map F ungreedy < trunc 2.1 empty fold_down _l F", binder:{x:int(30)})

# interpreter(script: "7.4 T if to_binder ^rescript shatter -8.5 _a fold_up _z unshift ¬ -0.1 ^rescript 9.2 fold_down ≤ reverse T _r 4.9 ^script greedy ≤ _x x ∩ to_span give known[] ≤ halt T 7 T 6.5 snap users ^length -7 to_span - []= to_list -0.3 know? T 0.9 infold_down _p halt 0.8 empty * greedy? -2.8 -8 if [] give + x 7 ∪ ungreedy _m F []= T _m F ¬ _n _b to_binder _h -2 -9 -4.4 _n -6.3 ∪ flatten dec _o infold_down * fold_down infold_up rewrap_by inc empty [] x _v rewrap_by to_bool > _h ∩ ^fork wrap emit rewrap_by _p below users empty neg F zap x ^length lowercase emit rewrap_by cover? x map rand -2 if > cover? x dec _a to_list F lowercase ÷ do 9 x x cover? > ^script ^rescript to_assembler + -4 2.7 to_decimal [] rotate known[] be to_bool copy eql flatten _b ∩ bundle step -5.9 bind T 7 to_binder if F fold_down known[] if ^script x neg flatten step above above x infold_up to_bool rand 2 users useful 0 swap to_interpreter _x emit lowercase ¬ ^length 4.0 to_list", binder:{x:int(30)})

# interpreter(script: "_r useful -3 -2.0 - 8 greedy? 3 -6 useful length -1 _x ∩ < ∨ inc -1.2 greedy? fold_down ∨ pop F - -9 ∧ wrap _l -4 ^script emit ≥ [] _u -1.3 emit to_binder 9 _e fold_up shift -6 ∩ to_bool do 8 shatter length inc ungreedy be length -8 fold_up wrap -8 length bind shift run ∩ fold_down fold_down [] -8 T flatten bind F []= 9 to_int to_assembler neg 9 x length -7 x lowercase _k greedy? ^rescript unshift to_span swap ^script []= -0.8 F x [] x -7 ^rescript ÷ to_assembler 5.6 ^fork cover? useful push + -2 x _e 4.2 _v x T 9 * -4.7 F ^rescript ¬ -8.8 -6.9 if to_assembler greedy? ^script ∧ x _u _t -1 * 9.4 -0.7 T to_int T to_bool -7 2.7 emit times_do ≥ ≤ emit shatter _k to_list x -9.0 -6 x x to_binder flatten * x x eql empty T + to_decimal -0.0 do ≥ x < T [] fold_down dec F inc greedy zap users ∧ 5 shift F ¬ -0.9 -9.4", binder:{x:int(30)})

# interpreter(script: "9 _b flatten x -8.2 * step -1 _m pop 7.1 _r [] infold_down shatter know? _y ^rescript 3 x if greedy? x _r ^quote T _z -8 -5 > step ^fork 5 3.7 map cover? 8.6 to_decimal ungreedy to_int above ÷ _e ^length T wrap 6 -6.1 x -5 to_binder -6.1 + -1 ^rescript -5.4 length T 1 ^length -5 T 6.5 F to_span x * T x 5 ∧ x to_decimal neg x * ÷ T users -4 _b 0 < below to_binder flatten copy to_decimal to_span ^fork infold_up keep ungreedy snap to_interpreter > * > give ≥ cover? emit x eql users x rotate x ^rescript times_do -1.0 to_span greedy? + ^fork _a x ∧ < F reverse to_interpreter 5 T ≤ 4 to_decimal 7 bundle x -6.9 rand swap to_assembler bind bundle x to_interpreter _b ungreedy shift wrap ungreedy [] map ^rescript below -2 keep ≤ -6 reverse -6.2 ∩ pop ∪ x ≥ wrap ÷ F greedy? x T -8 x x ^rescript ∧ x 8 _a x -0.8 - ¬ shift T x users F ∨ 8.8 _z know? run 6.5 x _r 7 _q F trunc to_assembler _q be 3.6 greedy? x ^script", binder:{x:int(30)})

# interpreter(script: "< ∧ bundle to_interpreter _k F trunc F rand 6.7 ∪ copies to_binder be ≥ ∨ rebind ^fork F swap swap 7.2 snap T _b x to_binder be map 8 -4.3 T bundle map < copy halt rewrap_by ¬ know? give ^quote shift ¬ -2.6 to_assembler T -5 ∨ * -4.9 times_do x users x -1.0 x ^fork reverse > lowercase 8 _x F > pop ^quote 8 x _k _g reverse infold_down to_bool empty reverse ¬ snap x * + 4.9 know? F run halt useful T -6 []= _l inc ∩ x > ungreedy -6.8 users x > x 9.5 + lowercase ≥ to_span keep T _w rewrap_by rand x F neg [] T run users > []= -7.0 bundle greedy? 0.7 T rewrap_by x reverse ∧ _t -7.3 shatter T if _l inc _m ∨ greedy _z 4.4 ^length users ÷ _n x _w x _l below ungreedy to_decimal _y snap users 7.6 rotate lowercase ÷ x x 8 _w reverse lowercase F ∧ x be shift x dec to_binder 7.3 swap F rebind bundle 0.6 ∨ 7.5 T to_interpreter F < -3 _j above -9 T", binder:{x:int(30)})

# interpreter(script: "x length 3 F wrap flatten zap ≥ unshift step known[] empty lowercase -4 < to_decimal rebind [] x F lowercase to_bool ungreedy T -0 infold_down be ∧ ∨ swap if T ÷ flatten rotate to_binder step _wkb neg greedy x ≥ x F ≥ F 6.3 2 * infold_up x ∪ to_assembler unshift _ymn do -9.3 fold_up ∩ 5 ∨ dec 8 flatten _nzd do T x push run ÷ x 7.9 pop T x -2.6 x -6.4 users below x to_int _xur length trunc x - x -0.4 inc greedy? -8.4 + be dec _khi _nun -0.1 unshift to_bool F be greedy? [] 1.8 x -7 flatten if keep _uxb if infold_down trunc x step -4 step _kuo copy x x F 0.1 zap F users keep F T - T map _lgu rebind -5.2 x - F zap to_decimal F ≤ x -4.8 users trunc ∨ to_assembler 2 ∨ bundle copies _npf rewrap_by rand ≤ useful - copy -4.6 [] 1.6 shatter greedy? shatter eql to_list -0.6 ¬ ungreedy flatten * if neg ¬ _cqe rotate greedy ÷ useful _jha to_list x zap fold_down be -5.6 _zog trunc ∧ _cht bundle shift empty -2.5 to_interpreter ∪ _sny F swap know? > _woi bundle - 6 to_int -7.3 flatten push 7 copy x lowercase inc x ¬ reverse _zgb run above < greedy? []= to_interpreter ≤ be T to_assembler to_list T _dkw -4 run x to_decimal useful F greedy 4.9 to_interpreter shatter -3 do -1 known[] bundle shift 8 rebind < x ≤ _yse rotate step * greedy? swap 6.8 F F F x do 2 flatten do keep map ungreedy to_interpreter to_decimal shatter _dtc flatten shatter rotate F users _osv 6 -1.5 -7 -6 length F reverse rand give know? to_decimal 6 copies ∩ fold_down bundle -9.6 -9 3 -4 flatten swap rotate zap -8 be to_list x copies above _ttf -5 -1.6 []= - < 0 -2.7 step x F x dec _fdp _ljn shift swap halt be ∧ infold_down -5.5 copy give F flatten dec empty F ≤ ÷ _dym x ∨ ÷ T -7 ¬ > to_assembler < ≤ * above _pbs [] -9.7", binder:{x:int(3)})


# interpreter(script:"halt _ezj 0.7 []= x copy do - bundle 2.1 to_assembler T step 4.3 F pop do eql pop push be x rebind halt x _cwl _yhp step * trunc to_assembler be x x users shift below x empty wrap know? ∨ reverse -8 x to_decimal ∧ x swap 0.7 to_list x be 3.2 _rtj - step known[] T step give x if _oiw greedy to_decimal ≤ -9 -2 -5 x T ∨ infold_down -2 F greedy T ≤ step keep _nuy x > wrap rewrap_by 3.1 reverse -7.5 x 5 F _trh to_assembler known[] x _ziq step _xct _egk eql give -8 useful x 3 x 6 copy greedy? _kzr trunc 8 copy []= ¬ known[] eql F *", binder:{x:int(3)})

# interpreter(script: "∨ 2.6 8.2 ≤ > above length be wrap x 9 x 6 -4 map x ∨ run ∩ to_assembler infold_up x unshift to_decimal to_bool -9 -9 x ungreedy 6.0 1.8 F ¬ ∩ < ungreedy wrap ≤ _ytz if neg bind _jxd 9 -6.8 ÷ rand wrap x T to_list reverse lowercase 5 F ∨ x 9.1 * shift T 0 to_interpreter fold_up _ouy to_decimal shift know? length -3.7 rewrap_by if zap known[] -9 rebind rand > _ayo x x _qva reverse length to_bool rotate ≤ - copies _jyn ∩ to_interpreter length x x _gur length _xip bind F infold_up ≤ []= _lwl -6 2.1 dec lowercase to_decimal to_bool fold_up to_decimal users below zap push reverse useful 7 5 - _zhb keep > push fold_up -1 greedy? give know? x -4.8 greedy if know? eql if -8.4 fold_up shift T flatten 9.6 * known[] 8.2 run above be x to_binder -0.0 bind fold_up 6 6 shatter _obn F trunc")

# interpreter(script: "infold_down ∩ x give push -4.4 _jhr _but rotate to_interpreter push to_int * pop x inc known[] bind -3.4 to_assembler be halt _hkn _apc T -8 rewrap_by if F + -7.3 rebind 0 * []= T T rebind _sce -7.0 give 2 keep F below x _xcp 7.4 known[] < length rebind x - 6 0 swap _tmt 0 -5.7 ÷ trunc T ∪ infold_down 3.5 rebind -3.1 _jlp empty unshift x 5.8 fold_up push 1 inc unshift shift x", binder:{x:Int.new(3)})

# interpreter(script: "to_assembler snap halt T + -9.9 to_interpreter 1.8 x map + []= snap x inc x rotate ≤ ungreedy ∨ rewrap_by neg x 5 inc if bundle reverse reverse useful x [] pop ∩ lowercase F know? x -2.9 8 8.4 copies shift * snap", binder:{x:Int.new(27)})

# interpreter(script: "be copies push 6 F 0 T 4.3 T to_interpreter x inc * shift be x push x ∨ to_int F + copies * ¬ zap copies to_binder copy halt know? bind map ≤ 0 T 4 reverse * - -3.7 []= halt > 0 give trunc shift inc F snap 0.4 / * * -4.1 inc F 3 x - + shift F copy to_interpreter 6 to_binder flatten neg swap -7.8 0.6 pop []= x -8.7 8.5 snap * 3.8 inc to_list dec lowercase lowercase rotate 5 x shatter x bundle reverse 6 do F rotate ungreedy give lowercase", binder:{x:Int.new(6)})

# interpreter(script: "8 0 T x do empty eql [] empty inc 3.1 give above F if ungreedy -5.2 6 - to_binder * neg - x to_interpreter 9 be unshift to_int rand shatter swap x ≥ zap ≤ bundle -2.2 ungreedy useful * 4 + 5 x", binder:{x:Int.new(27)})

# script: "3 x / if 0.3 x * greedy < 7 give ∨ 6.2 5.3 9 known to_binder > 3.4 greedy? below flatten do -5.0 rewrap_by F 0.8 length ungreedy halt []= zap map to_list 8 unshift F 2 halt useful if x T copies []= - zap above zap do known map do x 4 known run x - to_assembler x to_bool eql x run 9.2 -0.6 give 9.8 1.0 T -6.4 x trunc 9 ungreedy known dec ÷ T 7 trunc rewrap_by x 8 if 7 [] flatten reverse to_binder -2.6 4 ∨ 5 do to_bool x greedy >", binder:{x:Int.new(-30)}

# script: "to_binder x ≤ if < copy greedy ¬ rewrap_by rewrap_by to_list empty * 2 2 known 8 rotate T inc rewrap_by length step F x pop to_interpreter unshift greedy dec 3 ≥ T pop 2 [] F x ≥ to_decimal inc -8.4 x F to_interpreter 9.0 known copy known -0.6 1 x T to_binder be T useful ≤ ∪ length x rewrap_by x rotate ∨ x run 3 users x flatten users 2 dec rewrap_by ≤ / -3.1 push to_assembler greedy snap step -7.1 above x greedy? to_interpreter 5.7 7 copies if * rebind 7 x T ¬ []= halt", binder:{x:Int.new(15)}

# script:"copies eql unshift useful known -8.6 8 give 2.2 7 to_binder know? inc + ∪ ungreedy do shift + to_decimal [] ∩ do to_decimal be - 9 inc unshift reverse",
# binder:{x:Int.new(3)}
