#encoding: utf-8
require_relative '../lib/duck'
include Duck

bad_boy = 



begin
  bad_boy.trace!.run
rescue NoMethodError => e
  puts "\n\nERROR #{e.backtrace} #{e.message}: #{bad_boy.inspect} after #{bad_boy.ticks} ticks; staged: #{bad_boy.staged_item}"
end


# NOT FIXED: 




# JUST SLOW



# FIXED ?

# interpreter(script: "[] x 9 1.6 be unshift F -6 ^length pop 7.8 lowercase - fold_down T -2.7 to_assembler emit cover? above rand 1.3 rewrap_by 9 _y _g to_decimal ∨ infold_down F _f x ≤ greedy run pop * ≤ _c rand to_int 1 x below infold_up unshift ÷ + fold_up x greedy -0.9 fold_up -8 ∧ to_bool 4 ungreedy -7.7 _e - fold_up _x known[] _v infold_down rotate 5 x infold_down F []= 7 []= _z x swap _m x _g to_assembler to_int map _s unshift x to_bool ^script swap ∪ eql _b bind F T eql -2 fold_down useful copies _k -8 _m zap ^script -7.3 5 eql x 7 known[] -0.6 ≤ x _e ^rescript map push cover? x rewrap_by push 9 known[] x ^rescript wrap neg ^rescript wrap x cover? -2 x shift below _w step 4.3 x -2.8 greedy ^fork x ∪ rand empty to_interpreter x 9.0 bundle ^script T 2.5 ^rescript F give - halt ÷ map F ungreedy < trunc 2.1 empty fold_down _l F", binder:{x:int(30)})

# interpreter(script: "7.4 T if to_binder ^rescript shatter -8.5 _a fold_up _z unshift ¬ -0.1 ^rescript 9.2 fold_down ≤ reverse T _r 4.9 ^script greedy ≤ _x x ∩ to_span give known[] ≤ halt T 7 T 6.5 snap users ^length -7 to_span - []= to_list -0.3 know? T 0.9 infold_down _p halt 0.8 empty * greedy? -2.8 -8 if [] give + x 7 ∪ ungreedy _m F []= T _m F ¬ _n _b to_binder _h -2 -9 -4.4 _n -6.3 ∪ flatten dec _o infold_down * fold_down infold_up rewrap_by inc empty [] x _v rewrap_by to_bool > _h ∩ ^fork wrap emit rewrap_by _p below users empty neg F zap x ^length lowercase emit rewrap_by cover? x map rand -2 if > cover? x dec _a to_list F lowercase ÷ do 9 x x cover? > ^script ^rescript to_assembler + -4 2.7 to_decimal [] rotate known[] be to_bool copy eql flatten _b ∩ bundle step -5.9 bind T 7 to_binder if F fold_down known[] if ^script x neg flatten step above above x infold_up to_bool rand 2 users useful 0 swap to_interpreter _x emit lowercase ¬ ^length 4.0 to_list", binder:{x:int(30)})

# interpreter(script: "_r useful -3 -2.0 - 8 greedy? 3 -6 useful length -1 _x ∩ < ∨ inc -1.2 greedy? fold_down ∨ pop F - -9 ∧ wrap _l -4 ^script emit ≥ [] _u -1.3 emit to_binder 9 _e fold_up shift -6 ∩ to_bool do 8 shatter length inc ungreedy be length -8 fold_up wrap -8 length bind shift run ∩ fold_down fold_down [] -8 T flatten bind F []= 9 to_int to_assembler neg 9 x length -7 x lowercase _k greedy? ^rescript unshift to_span swap ^script []= -0.8 F x [] x -7 ^rescript ÷ to_assembler 5.6 ^fork cover? useful push + -2 x _e 4.2 _v x T 9 * -4.7 F ^rescript ¬ -8.8 -6.9 if to_assembler greedy? ^script ∧ x _u _t -1 * 9.4 -0.7 T to_int T to_bool -7 2.7 emit times_do ≥ ≤ emit shatter _k to_list x -9.0 -6 x x to_binder flatten * x x eql empty T + to_decimal -0.0 do ≥ x < T [] fold_down dec F inc greedy zap users ∧ 5 shift F ¬ -0.9 -9.4", binder:{x:int(30)})

# interpreter(script: "9 _b flatten x -8.2 * step -1 _m pop 7.1 _r [] infold_down shatter know? _y ^rescript 3 x if greedy? x _r ^quote T _z -8 -5 > step ^fork 5 3.7 map cover? 8.6 to_decimal ungreedy to_int above ÷ _e ^length T wrap 6 -6.1 x -5 to_binder -6.1 + -1 ^rescript -5.4 length T 1 ^length -5 T 6.5 F to_span x * T x 5 ∧ x to_decimal neg x * ÷ T users -4 _b 0 < below to_binder flatten copy to_decimal to_span ^fork infold_up keep ungreedy snap to_interpreter > * > give ≥ cover? emit x eql users x rotate x ^rescript times_do -1.0 to_span greedy? + ^fork _a x ∧ < F reverse to_interpreter 5 T ≤ 4 to_decimal 7 bundle x -6.9 rand swap to_assembler bind bundle x to_interpreter _b ungreedy shift wrap ungreedy [] map ^rescript below -2 keep ≤ -6 reverse -6.2 ∩ pop ∪ x ≥ wrap ÷ F greedy? x T -8 x x ^rescript ∧ x 8 _a x -0.8 - ¬ shift T x users F ∨ 8.8 _z know? run 6.5 x _r 7 _q F trunc to_assembler _q be 3.6 greedy? x ^script", binder:{x:int(30)})

# interpreter(script: "< ∧ bundle to_interpreter _k F trunc F rand 6.7 ∪ copies to_binder be ≥ ∨ rebind ^fork F swap swap 7.2 snap T _b x to_binder be map 8 -4.3 T bundle map < copy halt rewrap_by ¬ know? give ^quote shift ¬ -2.6 to_assembler T -5 ∨ * -4.9 times_do x users x -1.0 x ^fork reverse > lowercase 8 _x F > pop ^quote 8 x _k _g reverse infold_down to_bool empty reverse ¬ snap x * + 4.9 know? F run halt useful T -6 []= _l inc ∩ x > ungreedy -6.8 users x > x 9.5 + lowercase ≥ to_span keep T _w rewrap_by rand x F neg [] T run users > []= -7.0 bundle greedy? 0.7 T rewrap_by x reverse ∧ _t -7.3 shatter T if _l inc _m ∨ greedy _z 4.4 ^length users ÷ _n x _w x _l below ungreedy to_decimal _y snap users 7.6 rotate lowercase ÷ x x 8 _w reverse lowercase F ∧ x be shift x dec to_binder 7.3 swap F rebind bundle 0.6 ∨ 7.5 T to_interpreter F < -3 _j above -9 T", binder:{x:int(30)})

# interpreter(script: "x length 3 F wrap flatten zap ≥ unshift step known[] empty lowercase -4 < to_decimal rebind [] x F lowercase to_bool ungreedy T -0 infold_down be ∧ ∨ swap if T ÷ flatten rotate to_binder step _wkb neg greedy x ≥ x F ≥ F 6.3 2 * infold_up x ∪ to_assembler unshift _ymn do -9.3 fold_up ∩ 5 ∨ dec 8 flatten _nzd do T x push run ÷ x 7.9 pop T x -2.6 x -6.4 users below x to_int _xur length trunc x - x -0.4 inc greedy? -8.4 + be dec _khi _nun -0.1 unshift to_bool F be greedy? [] 1.8 x -7 flatten if keep _uxb if infold_down trunc x step -4 step _kuo copy x x F 0.1 zap F users keep F T - T map _lgu rebind -5.2 x - F zap to_decimal F ≤ x -4.8 users trunc ∨ to_assembler 2 ∨ bundle copies _npf rewrap_by rand ≤ useful - copy -4.6 [] 1.6 shatter greedy? shatter eql to_list -0.6 ¬ ungreedy flatten * if neg ¬ _cqe rotate greedy ÷ useful _jha to_list x zap fold_down be -5.6 _zog trunc ∧ _cht bundle shift empty -2.5 to_interpreter ∪ _sny F swap know? > _woi bundle - 6 to_int -7.3 flatten push 7 copy x lowercase inc x ¬ reverse _zgb run above < greedy? []= to_interpreter ≤ be T to_assembler to_list T _dkw -4 run x to_decimal useful F greedy 4.9 to_interpreter shatter -3 do -1 known[] bundle shift 8 rebind < x ≤ _yse rotate step * greedy? swap 6.8 F F F x do 2 flatten do keep map ungreedy to_interpreter to_decimal shatter _dtc flatten shatter rotate F users _osv 6 -1.5 -7 -6 length F reverse rand give know? to_decimal 6 copies ∩ fold_down bundle -9.6 -9 3 -4 flatten swap rotate zap -8 be to_list x copies above _ttf -5 -1.6 []= - < 0 -2.7 step x F x dec _fdp _ljn shift swap halt be ∧ infold_down -5.5 copy give F flatten dec empty F ≤ ÷ _dym x ∨ ÷ T -7 ¬ > to_assembler < ≤ * above _pbs [] -9.7", binder:{x:int(3)})


# interpreter(script:"halt _ezj 0.7 []= x copy do - bundle 2.1 to_assembler T step 4.3 F pop do eql pop push be x rebind halt x _cwl _yhp step * trunc to_assembler be x x users shift below x empty wrap know? ∨ reverse -8 x to_decimal ∧ x swap 0.7 to_list x be 3.2 _rtj - step known[] T step give x if _oiw greedy to_decimal ≤ -9 -2 -5 x T ∨ infold_down -2 F greedy T ≤ step keep _nuy x > wrap rewrap_by 3.1 reverse -7.5 x 5 F _trh to_assembler known[] x _ziq step _xct _egk eql give -8 useful x 3 x 6 copy greedy? _kzr trunc 8 copy []= ¬ known[] eql F *", binder:{x:int(3)})

# interpreter(script: "∨ 2.6 8.2 ≤ > above length be wrap x 9 x 6 -4 map x ∨ run ∩ to_assembler infold_up x unshift to_decimal to_bool -9 -9 x ungreedy 6.0 1.8 F ¬ ∩ < ungreedy wrap ≤ _ytz if neg bind _jxd 9 -6.8 ÷ rand wrap x T to_list reverse lowercase 5 F ∨ x 9.1 * shift T 0 to_interpreter fold_up _ouy to_decimal shift know? length -3.7 rewrap_by if zap known[] -9 rebind rand > _ayo x x _qva reverse length to_bool rotate ≤ - copies _jyn ∩ to_interpreter length x x _gur length _xip bind F infold_up ≤ []= _lwl -6 2.1 dec lowercase to_decimal to_bool fold_up to_decimal users below zap push reverse useful 7 5 - _zhb keep > push fold_up -1 greedy? give know? x -4.8 greedy if know? eql if -8.4 fold_up shift T flatten 9.6 * known[] 8.2 run above be x to_binder -0.0 bind fold_up 6 6 shatter _obn F trunc")

# interpreter(script: "infold_down ∩ x give push -4.4 _jhr _but rotate to_interpreter push to_int * pop x inc known[] bind -3.4 to_assembler be halt _hkn _apc T -8 rewrap_by if F + -7.3 rebind 0 * []= T T rebind _sce -7.0 give 2 keep F below x _xcp 7.4 known[] < length rebind x - 6 0 swap _tmt 0 -5.7 ÷ trunc T ∪ infold_down 3.5 rebind -3.1 _jlp empty unshift x 5.8 fold_up push 1 inc unshift shift x", binder:{x:Int.new(3)})

# interpreter(script: "to_assembler snap halt T + -9.9 to_interpreter 1.8 x map + []= snap x inc x rotate ≤ ungreedy ∨ rewrap_by neg x 5 inc if bundle reverse reverse useful x [] pop ∩ lowercase F know? x -2.9 8 8.4 copies shift * snap", binder:{x:Int.new(27)})

# interpreter(script: "be copies push 6 F 0 T 4.3 T to_interpreter x inc * shift be x push x ∨ to_int F + copies * ¬ zap copies to_binder copy halt know? bind map ≤ 0 T 4 reverse * - -3.7 []= halt > 0 give trunc shift inc F snap 0.4 / * * -4.1 inc F 3 x - + shift F copy to_interpreter 6 to_binder flatten neg swap -7.8 0.6 pop []= x -8.7 8.5 snap * 3.8 inc to_list dec lowercase lowercase rotate 5 x shatter x bundle reverse 6 do F rotate ungreedy give lowercase", binder:{x:Int.new(6)})

# interpreter(script: "8 0 T x do empty eql [] empty inc 3.1 give above F if ungreedy -5.2 6 - to_binder * neg - x to_interpreter 9 be unshift to_int rand shatter swap x ≥ zap ≤ bundle -2.2 ungreedy useful * 4 + 5 x", binder:{x:Int.new(27)})

# script: "3 x / if 0.3 x * greedy < 7 give ∨ 6.2 5.3 9 known to_binder > 3.4 greedy? below flatten do -5.0 rewrap_by F 0.8 length ungreedy halt []= zap map to_list 8 unshift F 2 halt useful if x T copies []= - zap above zap do known map do x 4 known run x - to_assembler x to_bool eql x run 9.2 -0.6 give 9.8 1.0 T -6.4 x trunc 9 ungreedy known dec ÷ T 7 trunc rewrap_by x 8 if 7 [] flatten reverse to_binder -2.6 4 ∨ 5 do to_bool x greedy >", binder:{x:Int.new(-30)}

# script: "to_binder x ≤ if < copy greedy ¬ rewrap_by rewrap_by to_list empty * 2 2 known 8 rotate T inc rewrap_by length step F x pop to_interpreter unshift greedy dec 3 ≥ T pop 2 [] F x ≥ to_decimal inc -8.4 x F to_interpreter 9.0 known copy known -0.6 1 x T to_binder be T useful ≤ ∪ length x rewrap_by x rotate ∨ x run 3 users x flatten users 2 dec rewrap_by ≤ / -3.1 push to_assembler greedy snap step -7.1 above x greedy? to_interpreter 5.7 7 copies if * rebind 7 x T ¬ []= halt", binder:{x:Int.new(15)}

# script:"copies eql unshift useful known -8.6 8 give 2.2 7 to_binder know? inc + ∪ ungreedy do shift + to_decimal [] ∩ do to_decimal be - 9 inc unshift reverse",
# binder:{x:Int.new(3)}
